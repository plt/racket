#lang zuo

(provide hash-set*
         target->path

         string-tree->shell

         process/wait

         racket
         racket/process
         raco
         raco/process
         
         make-raco-driver
         make-zo-target

         shell-subst
         configured-targets-at)

(define (hash-set* ht . keys+vals)
  (let loop ([ht ht] [keys+vals keys+vals])
    (if (null? keys+vals)
        ht
        (loop (hash-set ht (car keys+vals) (cadr keys+vals))
              (cddr keys+vals)))))

(define (target->path t) (if (target? t) (target-path t) t))

(define (process/wait command . args)
  (fd-write (fd-open-output 'stdout)
            (~a (string-tree->shell (cons command args)) "\n"))
  (define p (apply process (cons command args)))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed")))

(struct raco-driver (vars target config-getter))

(define (find-racket vars)
  (or (hash-ref vars 'racket #f)
      (at-source "../bin" (.exe "racket"))))

(define (string-tree->shell . args)
  (build-shell (let loop ([args args])
                 (cond
                   [(string? args)
                    (string->shell args)]
                   [(list? args)
                    (map loop args)]
                   [(hash? args)
                    ;; assume last and intended as options
                    ""]
                   [else (~s args)]))))

(define (racket/process vars . args)
  (define racket-exe (find-racket vars))
  (fd-write (fd-open-output 'stdout)
            (~a (string-tree->shell (cons racket-exe args)) "\n"))
  (apply process (list* racket-exe args)))

(define (racket vars . args)
  (define p (apply racket/process (cons vars args)))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed")))

(define (raco/process vars . args)
  (apply racket/process (list* vars
                               "-N" "raco" "-l-" "raco"
                               args)))

(define (raco vars . args)
  (define p (apply raco/process (cons vars args)))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed")))

(define (make-zo-target stamp-file src raco-driver)
  (target stamp-file
          (lambda (path token)
            (rule (list (raco-driver-target raco-driver))
                  (lambda ()
                    (define vars (raco-driver-vars raco-driver))
                    (raco vars "make" src)
                    (define paths (get-dependencies vars src))
                    (define out (fd-open-output stamp-file :truncate))
                    (for-each
                     (lambda (path)
                       (build/dep path token)
                       ;; writing the hash of every file to "stamp-file" means that
                       ;; we expect any change to effect the way that the compiled
                       ;; file runs:
                       (fd-write out (file-sha1 path token)))
                     paths)
                    (fd-close out))))))

(define (get-dependencies vars file)
  (define p (racket vars
                    (at-source "zuo-help.rkt")
                    "--dependencies"
                    file
                    (hash 'stdout 'pipe)))
  (define config-str (fd-read (hash-ref p 'stdout) eof))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed"))
  (string-read config-str))

(define (make-raco-driver vars racket-config.db)
  (raco-driver
   vars
   (target racket-config.db
           (lambda (path token)
             (rule (list (find-racket vars))
                   (lambda ()
                     (save-racket-configuration (extract-racket-configuration vars) path)))))
   (lambda ()
     (load-racket-configuration racket-config.db))))

(define (extract-racket-configuration vars)
  (define p (racket/process vars
                            (at-source "zuo-help.rkt")
                            "--get-config"
                            (hash 'stdout 'pipe)))
  (define config-str (fd-read (hash-ref p 'stdout) eof))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed"))
  (define l (string-read config-str))
  (foldl (lambda (a config)
           (hash-set config (car a) (cadr a)))
         (hash)
         l))

(define (save-racket-configuration config path)
  (mkdir-p (path-only path))
  (display-to-file (apply ~a
                          (map (lambda (key)
                                 (~a (~s (cons key (hash-ref config key))) "\n"))
                               (hash-keys config)))
                   path
                   :truncate))

(define (load-racket-configuration path)
  (define h (cleanable-file path))
  (define l (string-read (file->string path)))
  (cleanable-cancel h)
  (foldl (lambda (p config)
           (hash-set config (car p) (cdr p)))
         (hash)
         l))

(define (shell-subst str config)
  (let loop ([i 0])
    (cond
      [(> (+ i 2) (string-length str)) str]
      [(and (= (char "$") (string-ref str i))
            (= (char "{") (string-ref str (+ i 1))))
       (let ([end (let loop ([i (+ i 2)])
                    (cond
                      [(= i (string-length str)) (error "didn't find closer" str)]
                      [(= (char "}") (string-ref str i)) i]
                      [else (loop (+ i 1))]))])
         (shell-subst (~a (substring str 0 i)
                          (hash-ref config (string->symbol (substring str (+ i 2) end)))
                          (substring str (+ end 1)))
                      config))]
      [else (loop (+ i 1))])))

(define (configured-targets-at configure configure-args more-inputs
                               output-makefile more-outputs
                               script vars)
  (define dir (path-only output-makefile))
  (mkdir-p dir)
  (build (target output-makefile
                 (lambda (name token)
                   (rule (list* configure
                                (input-data-target 'configure-args configure-args)
                                more-inputs)
                         (lambda ()
                           (shell/wait (apply build-shell
                                              (map string->shell
                                                   (cons (ensure-path
                                                          (if (relative-path? configure)
                                                              (find-relative-path dir configure)
                                                              configure))
                                                         configure-args)))
                                       (hash 'dir dir)))))
                 (hash 'quiet? #t
                       'co-outputs more-outputs)))
  ((dynamic-require script 'targets-at) (make-at-dir dir) vars))

;; in a shell, we need to have "./" when running something in the same directory
(define (ensure-path path)
  (if (not (car (split-path path)))
      (~a "./" path)
      path))
