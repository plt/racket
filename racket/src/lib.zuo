#lang zuo

(provide hash-set*

         racket
         racket/wait
         raco
         raco/wait
         
         make-raco-driver
         make-zo-target

         shell-subst
         configured-targets-at)

(define (hash-set* ht . keys+vals)
  (let loop ([ht ht] [keys+vals keys+vals])
    (if (null? keys+vals)
        ht
        (loop (hash-set ht (car keys+vals) (cadr keys+vals))
              (cddr keys+vals)))))

(struct raco-driver (vars target config-getter))

(define (find-racket vars)
  (or (hash-ref vars 'racket #f)
      (at-source "../bin" (.exe "racket"))))

(define (racket vars . args)
  (define racket-exe (find-racket vars))
  (fd-write (fd-open-output 'stdout)
            (~a (apply build-shell (list* (string->shell racket-exe)
                                          (map (lambda (arg)
                                                 (if (string? arg)
                                                     (string->shell arg)
                                                     ""))
                                               args)))
                "\n"))
  (apply process (list* racket-exe args)))

(define (racket/wait vars . args)
  (define p (apply racket (cons vars args)))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed")))

(define (raco vars . args)
  (apply racket (list* vars
                       "-N" "raco" "-l-" "raco"
                       args)))

(define (raco/wait vars . args)
  (define p (apply raco (cons vars args)))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed")))

(define (make-zo-target stamp-file src raco-driver)
  (target stamp-file
          (lambda (path token)
            (rule (list (raco-driver-target raco-driver))
                  (lambda ()
                    (define vars (raco-driver-vars raco-driver))
                    (raco/wait vars "make" src)
                    (define paths (get-dependencies vars src))
                    (define out (fd-open-output stamp-file :truncate))
                    (for-each
                     (lambda (path)
                       (build/recur path token)
                       ;; writing the hash of every file to "stamp-file" means that
                       ;; we expect any change to effect the way that the compiled
                       ;; file runs:
                       (fd-write out (file-sha1 path token)))
                     paths)
                    (fd-close out))))))

(define (get-dependencies vars file)
  (define p (racket vars
                    (at-source "zuo-help.rkt")
                    "--dependencies"
                    file
                    (hash 'stdout 'pipe)))
  (define config-str (fd-read (hash-ref p 'stdout) eof))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed"))
  (string-read config-str))

(define (make-raco-driver vars racket-config.db)
  (raco-driver
   vars
   (target racket-config.db
           (lambda (path token)
             (rule (list (find-racket vars))
                   (lambda ()
                     (save-racket-configuration (extract-racket-configuration vars) path)))))
   (lambda ()
     (load-racket-configuration racket-config.db))))

(define (extract-racket-configuration vars)
  (define p (racket vars
                    (at-source "zuo-help.rkt")
                    "--get-config"
                    (hash 'stdout 'pipe)))
  (define config-str (fd-read (hash-ref p 'stdout) eof))
  (process-wait (hash-ref p 'process))
  (unless (= 0 (process-status (hash-ref p 'process)))
    (error "failed"))
  (define l (string-read config-str))
  (foldl (lambda (a config)
           (hash-set config (car a) (cadr a)))
         (hash)
         l))

(define (save-racket-configuration config path)
  (mkdir-p (path-only path))
  (display-to-file (apply ~a
                          (map (lambda (key)
                                 (~a (~s (cons key (hash-ref config key))) "\n"))
                               (hash-keys config)))
                   path
                   :truncate))

(define (load-racket-configuration path)
  (define h (cleanable-file path))
  (define l (string-read (file->string path)))
  (cleanable-cancel h)
  (foldl (lambda (p config)
           (hash-set config (car p) (cdr p)))
         (hash)
         l))

(define (shell-subst str config)
  (let loop ([i 0])
    (cond
      [(> (+ i 2) (string-length str)) str]
      [(and (= (char "$") (string-ref str i))
            (= (char "{") (string-ref str (+ i 1))))
       (let ([end (let loop ([i (+ i 2)])
                    (cond
                      [(= i (string-length str)) (error "didn't find closer" str)]
                      [(= (char "}") (string-ref str i)) i]
                      [else (loop (+ i 1))]))])
         (shell-subst (~a (substring str 0 i)
                          (hash-ref config (string->symbol (substring str (+ i 2) end)))
                          (substring str (+ end 1)))
                      config))]
      [else (loop (+ i 1))])))

(define (configured-targets-at configure configure-args more-inputs output-makefile script vars)
  (define dir (path-only output-makefile))
  (build (target output-makefile
                 (lambda (name token)
                   (rule (list* configure
                                (input-data-target 'configure-args configure-args)
                                more-inputs)
                         (lambda ()
                           (shell/wait (apply build-shell
                                              (map string->shell
                                                   (cons (find-relative-path dir configure)
                                                         configure-args)))
                                       (hash 'dir dir)))))
                 (hash 'quiet? #t)))
  ((dynamic-require script 'targets-at) (make-at-dir dir) vars))
