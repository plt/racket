#lang zuo
(require "machine.zuo")

(define default-options
  (hash
   ;; o determines the optimize level
   'o 3

   ;; d is the debug level at which the system should be built
   'd 0

   ;; cl determines the commonization level (#f means the default)
   'cl #f

   ;; i determines whether inspector-information is generated
   'i #f

   ;; cp0 determines the number of cp0 (source optimizer) iterations run
   'cp0 2

   ;; fc determines whether fasl objects are compressed
   'fc #t

   ;; xf determines the compression format (#f means the default)
   'xf #f

   ;; xl determine the compression level (#f means the default)
   'xl #f

   ;; p (xp) determines whether source profiling is enabled
   'p #f
   'xp #f

   ;; bp (xpb) determines whether binary profiling is enabled
   'bp #f
   'xbp #f

   ;; c determines whether covin files are generated
   'c #f

   ;; loadspd determines whether source-profile data is loaded
   'loadspd #f

   ;; dumpspd determines whether source-profile data is dumped
   'dumpspd #f

   ;; loadbpd determines whether binary-profile data is loaded
   'loadbpd #f

   ;; dumpbpd determines whether binary-profile data is dumped
   'dumpbpd #f

   ;; compile determines the entry point for compilng files
   ;; another useful value for this is compile-with-asm, defined in debug.ss
   'compile 'compile-file

   ;; pdhtml determines whether profile-dump-html is called at the end of a build
   'pdhtml #f

   ;; gac determines whether cost-center allocation counts are generated
   'gac #f

   ;; gic determines whether cost-center instruction counts are generated
   'gic #f

   ;; pps determines whether pass timings are printed
   'pps #f))

(define (targets-at at-dir [vars (hash)])
  (define config (config-file->hash (at-dir "../Makefile")))
  (define (lookup key) (or (hash-ref vars key #f)
                           (hash-ref config key #f)))
  (define (opt key) (let ([v (hash-ref default-options key)]
                          [cv (lookup key)])
                      (if cv
                          (cond
                            [(boolean? v)
                             (cond
                               [(equal? cv "t") #t]
                               [(equal? cv "f") #f]
                               [else (error (~a "value for " key " is not \"t\" or \"f\"")
                                            cv)])]
                            [(integer? v)
                             (or (string->integer cv)
                                 (error (~a "value for " key " is not an integer")
                                        cv))]
                            [else (string->symbol cv)])
                          v)))

  (define m (lookup 'm))
  (define host-m (or (lookup 'host-m) m))
  (define host-workarea (or (lookup 'host-workarea) (at-dir "..")))
  (define arch (m->arch m))
  (define arch.ss (~a (arch->backend arch) ".ss"))

  (define mach-src+dep+more-srcs (get-machine-files m arch))

  (define (at-boot s) (at-dir (build-path "../boot/" m s)))

  (define petite.boot (at-boot "petite.boot"))
  (define scheme.boot (at-boot "scheme.boot"))

  (define scheme.h (at-boot "scheme.h"))
  (define equates.h (at-boot "equates.h"))
  (define gc-ocd.inc (at-boot "gc-ocd.inc"))
  (define gc-oce.inc (at-boot "gc-oce.inc"))
  (define gc-par.inc (at-boot "gc-par.inc"))
  (define heapcheck.inc (at-boot "heapcheck.inc"))

  ;; putting cpnanopass.patch early for maximum make --jobs=2 benefit
  (define patch-names
    (list "patch.patch" "cpnanopass.patch" "cpprim.patch" "cprep.patch" "cpcheck.patch"
          "cp0.patch" "cpvalid.patch" "cptypes.patch" "cpcommonize.patch" "cpletrec.patch"
          "reloc.patch"
          "compile.patch" "fasl.patch" "vfasl.patch" "pbchunk.patch" "syntax.patch" "env.patch"
          "read.patch" "interpret.patch" "ftype.patch" "strip.patch"
          "ubify.patch" "back.patch"))

  ;; ordering constraints in "petite.boot":
  ;;  first: library, prims, mathprims, front, 5_?
  ;;  last: back
  ;;  newhash before read
  ;;  io before read
  ;;  event before 4
  ;;  ftype after syntax
  ;;  layout and record before strnum (first define-record)
  ;;  date before 7
  ;; (there may be other constraints as well)

  (define base-names
    (list "library.ss" "prims.ss" "mathprims.ss" "record.ss" "5_1.ss" "5_2.ss" "5_3.ss"
          "strnum.ss" "bytevector.ss" "5_4.ss" "5_6.ss" "5_7.ss"
          "event.ss" "4.ss" "front.ss" "foreign.ss" "6.ss" "print.ss" "newhash.ss"
          "format.ss" "date.ss" "7.ss" "cafe.ss" "trace.ss" "engine.ss"
          "interpret.ss" "cprep.ss" "cpcheck.ss" "cp0.ss" "cpvalid.ss" "cptypes.ss"
          "cpcommonize.ss" "cpletrec.ss" "inspect.ss"
          "enum.ss" "io.ss" "read.ss" "primvars.ss" "syntax.ss" "costctr.ss" "expeditor.ss"
          "exceptions.ss" "pretty.ss" "env.ss"
          "fasl.ss" "vfasl.ss" "pbchunk.ss" "reloc.ss" "pdhtml.ss" "strip.ss" "ftype.ss" "back.ss"))

  (define base-srcs (map at-source base-names))

  (define base-objs
    (map (lambda (s) (at-dir (path-replace-suffix s (~a "." m))))
         base-names))

  (define compiler-names
    (list "cpnanopass.ss" "cpprim.ss" "compile.ss" "cback.ss"))

  (define compiler-srcs
    (map at-source compiler-names))

  (define compiler-objs
    (map (lambda (s) (at-dir (path-replace-suffix s (~a "." m))))
         compiler-names))

  (define type-src-files
    ;; files that are `include`d by other files:
    (list "base-lang.ss" "expand-lang.ss" "primref.ss" "types.ss" "io-types.ss"
          "fasl-helpers.ss" "hashtable-types.ss" "strip-types.ss"))
  (define type-srcs
    (map at-source type-src-files))
  (define type-src-copies
    (map at-dir type-src-files))

  (define cpnanopass-src-files
    ;; files that are `include`d by "cpnanopass.ss" and "cpprim.ss"
    (list arch.ss "np-languages.ss" "fxmap.ss" "cptypes-lattice.ss"
          "np-register.ss" "np-info.ss" "np-help.ss"))
  (define cpnanopass-srcs
    (map at-source cpnanopass-src-files))

  (define included-srcs
    ;; all files that are `include`d by other files:
    (append (map at-source
                 (list "debug.ss" "primdata.ss" "layout.ss"))
            (append type-srcs
                    cpnanopass-srcs)))

  (define other-srcs
    ;; files that are used to initialize the compiler
    (map at-source
         (list "cmacros.ss" "priminfo.ss" "setup.ss" "env.ss"
               "mkheader.ss" "mkgc.ss")))

  (define all-srcs
    (append base-srcs
            compiler-srcs
            included-srcs
            other-srcs))

  (define profile-dump-source "source.pd")
  (define profile-dump-block "block.pd")

  ;; We'll run `scheme` with the build directory as the current
  ;; directory, because we need to generate "machine.def" there;
  ;; use `at-cwd` to convert a path from the current directory
  ;; to the will-be-current directory
  (define at-cwd
    (let ([will-be-dir (at-dir ".")])
      (lambda (p)
        (find-relative-path will-be-dir p))))

  (define (run-scheme/status what script inputs)
    (define scheme.exe (build-path host-workarea "bin" host-m "scheme"))
    (displayln (~a "running " scheme.exe " to build " what))
    (define env (cons
                 (cons "SCHEMEHEAPDIRS" (path->complete-path
                                         (build-path host-workarea "boot" host-m)))
                 (hash-ref (runtime-env) 'env)))
    (define p (apply process
                     (cons (at-cwd scheme.exe)
                           (append (list "-q")
                                   (map (lambda (s)
                                          (if (= (char "-") (string-ref s 0))
                                              s
                                              (at-cwd s)))
                                        inputs)
                                   (list (hash 'dir (at-dir ".")
                                               'stdin 'pipe
                                               'env env))))))
    (define to (hash-ref p 'stdin))
    (fd-write to (string-join (map ~s script)))
    (fd-close to)
    (thread-process-wait (hash-ref p 'process))
    (process-status (hash-ref p 'process)))

  (define (run-scheme what script inputs)
    (unless (= 0 (run-scheme/status what script inputs))
      (error "failed")))

  (define (cp0+gc-control)
    `((run-cp0 (lambda (cp0 x)
                 (do ([i ,(opt 'cp0) (fx- i 1)] [x x (cp0 x)])
                     ((fx= i 0) x))))
      (collect-trip-bytes (expt 2 24))
      (collect-request-handler (lambda () (collect 0 1)))
      (collect 1 2)))

  ;; Script to compile the final version of file, where a certain
  ;; amount of configuration is in a file that is loaded before this
  ;; script
  (define (make-final-compile-script srcs dests asm? finish-steps)
    ;; Generate expressions for Chez Scheme to eval:
    `((reset-handler abort)
      (optimize-level ,(opt 'o))
      (debug-level ,(opt 'd))
      (commonization-level (or ,(opt 'cl) (commonization-level)))
      (fasl-compressed ,(opt 'fc))
      (compress-format (or ,(opt 'xf) (compress-format)))
      (compress-level (or ,(opt 'xl) (compress-level)))
      (when ,(opt 'p) (compile-profile 'source))
      (when ,(opt 'bp) (compile-profile 'block))
      (when ,(opt 'loadspd) (profile-load-data ,profile-dump-source))
      (when ,(opt 'loadbpd) (profile-load-data ,profile-dump-block))
      (generate-inspector-information ,(opt 'i))
      (generate-allocation-counts ,(opt 'gac))
      (generate-instruction-counts ,(opt 'gic))
      (when ,asm? (print-gensym 'pretty/suffix))
      (,(string->symbol "#%$enable-pass-timing") ,(opt 'pps))
      (generate-covin-files ,(opt 'c))
      ,@(cp0+gc-control)
      ,@(map (lambda (dest)
               `(begin (delete-file ,(at-cwd (path-replace-suffix dest ".covin"))) (void)))
             dests)
      (time (let ()
              ,@(map (lambda (src dest)
                       `(,(if asm? 'compile-with-asm (opt 'compile)) ,(at-cwd src) ,(at-cwd dest) ',(string->symbol m)))
                     srcs
                     dests)))
      (printf "    ~a bytes peak memory use~n" (maximum-memory-bytes))
      ,@finish-steps
      (when ,(opt 'pdhtml) (profile-dump-html))
      (when ,(opt 'dumpspd) (profile-dump-data ,profile-dump-source))
      (when ,(opt 'dumpbpd) (profile-dump-data ,profile-dump-block))))

  (define (make-compile-single-script src dest asm?)
    (make-final-compile-script (list src) (list dest) asm? '()))

  (define (make-compile-at-once-script base-srcs base-dests petite.boot-file
                                       compiler-srcs compiler-dests scheme.boot-file)
    (make-final-compile-script
     (append base-srcs compiler-srcs) (append base-dests compiler-dests) #f
     `((when ,(opt 'pps) (,(string->symbol "#%$print-pass-stats")))
       ,@(make-bootfile-step-script petite.boot '() base-dests)
       ,@(make-bootfile-step-script scheme.boot '("petite") compiler-dests))))

  (define (make-bootfile-step-script .boot pre-boots dests)
    `((begin (delete-file ,(path-replace-suffix .boot ".covin")) (void))
      (,(string->symbol "#%$make-boot-file") ,(at-cwd .boot) ',(string->symbol m) ',pre-boots ,@(map at-cwd dests))))

  (define (make-bootfile-script .boot pre-boots dests)
    `((reset-handler abort)
      (generate-covin-files ,(opt 'c))
      ,@(make-bootfile-step-script .boot pre-boots dests)))

  ;; Script to compile the version of a file used to compile the final versions
  (define (make-compiler-compile-script src dest mode)
    `((reset-handler abort)
      (base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))
      (keyboard-interrupt-handler (lambda () (display "interrupted---aborting\n") (reset)))
      (optimize-level ,(opt 'o))
      (debug-level ,(opt 'd))
      (commonization-level (or ,(opt 'cl) (commonization-level)))
      (fasl-compressed ,(opt 'fc))
      (compress-format (or ,(opt 'xf) (compress-format)))
      (compress-level (or ,(opt 'xl) (compress-level)))
      (generate-inspector-information ,(opt 'i))
      ,@(cond
          [(eq? mode 'normal)
           `((subset-mode 'system)
             (compile-file ,(at-cwd src) ,(at-cwd dest)))]
          [(eq? mode 'patch)
           `(,@(cp0+gc-control)
             (time (compile-file ,(at-cwd src) ,(at-cwd dest) ',(string->symbol host-m)))
             (printf "    ~a bytes peak memory use~n" (maximum-memory-bytes)))]
          [(eq? mode 'library)
           `((compile-library ,(at-cwd src) ,(at-cwd dest)))])))

  ;; Create a `:target` line for files that are `include`d, were need a link or copy
  ;; in the build directory
  (define (copy-target src)
    `[:target ,(at-dir (file-name-from-path src)) (,src)
              ,(lambda (path token)
                 (cp/ln src path))])

  (define (cat srcs dest)
    (let ([s (apply ~a (map file->string srcs))])
      (display-to-file s dest)))

  ;; Create a `:target` for files like "cmacros.so", which are compiled
  ;; to compile the compiler
  (define (compilation-preamble-target .so deps loads)
    (define .ss (at-source (path-replace-suffix (file-name-from-path .so) ".ss")))
    `[:target ,.so (,.ss ,@deps ,@loads)
              ,(lambda (path token)
                 (run-scheme path
                             (make-compiler-compile-script .ss path 'normal)
                             loads))])

  ;; Create a `:depend` line for a file that `include`s other files
  (define (include-dep name src-names)
    `[:depend (,(at-dir (~a name "." m)) ,(at-dir (~a name ".so")) ,(at-dir (~a name ".patch")))
              ,(map at-dir src-names)])

  (define (run-scheme-header-script dest make-script mk.so*)
    (define tmp (~a dest ".next"))
    (define tmp-h (cleanable-file tmp))
    (mkdir* (path-only tmp))
    (run-scheme dest
                `((reset-handler abort)
                  ,@(make-script (at-cwd tmp)))
                (append macro-objs mk.so*))
    (if (and (file-exists? dest)
             (equal? (file->string dest)
                     (file->string tmp)))
        (rm tmp)
        (mv tmp dest))
    (cleanable-cancel tmp-h))

  (define (look-for-fixpoint n rebuild)
    (define sbb (build-path (path-only petite.boot) "sbb"))
    (define scb (build-path (path-only scheme.boot) "scb"))
    (let loop ([i 0])
      (cond
        [(= i n) (error "failed to arrive at a fixpoint")]
        [(and (file-exists? petite.boot)
              (file-exists? scheme.boot))
         (mv petite.boot sbb)
         (mv scheme.boot scb)
         (cp sbb petite.boot)
         (cp scb scheme.boot)
         (rebuild)
         (define result
           (run-scheme/status "fixpoint check"
                              `((reset-handler abort)
                                (base-exception-handler (lambda (c) (fresh-line) (display-condition c) (newline) (reset)))
                                (begin
                                  (,(string->symbol "#%$fasl-file-equal?") ,(at-cwd sbb) ,(at-cwd petite.boot))
                                  (,(string->symbol "#%$fasl-file-equal?") ,(at-cwd scb) ,(at-cwd scheme.boot))
                                  (void)))
                              `("-B" ,sbb)))
         (mv sbb petite.boot)
         (mv scb scheme.boot)
         (cond
           [(= result 0)
            (alert "done (unchanged after rebuild)")]
           [else
            (loop (+ i 1))])]
        [else
         (rebuild)
         (loop (+ i 1))])))

  (define machine.def (at-dir "machine.def"))
  (define cmacros.so (at-dir "cmacros.so"))
  (define primvars.so (at-dir "primvars.so"))
  (define priminfo.so (at-dir "priminfo.so"))
  (define env.so (at-dir "env.so"))
  (define setup.so (at-dir "setup.so"))
  (define mkheader.so (at-dir "mkheader.so"))
  (define mkgc.so (at-dir "mkgc.so"))

  (define macro-objs
    (list cmacros.so priminfo.so primvars.so env.so setup.so))

  (define nanopass.ss (at-source "../nanopass/nanopass.ss"))
  (define nanopass.so (at-dir "nanopass.so"))

  (define output-headers
    (list scheme.h equates.h gc-ocd.inc gc-oce.inc gc-par.inc heapcheck.inc))

  (define (add-patchfile l)
    (if (string=? m host-m)
        l
        (append l (list (at-dir "xpatch")))))

  (define the-targets
    (make-targets
     `([:target default (,petite.boot ,scheme.boot ,@output-headers) ,void]

       ,@(map copy-target included-srcs)

       ,@(map (lambda (file)
                (define src (at-source file))
                `[:target ,(at-dir file) (,src)
                          ,(lambda (path token)
                             (mkdir* (path-only path))
                             (cp/ln src path))])
              '("../unicode/unicode-char-cases.ss"
                "../unicode/unicode-charinfo.ss"))

       [:target ,machine.def (,(input-data-target 'machine m)
                              ,@(map at-source (cons (caar mach-src+dep+more-srcs)
                                                     (cdr mach-src+dep+more-srcs))))
                ,(lambda (dest token)
                   ((cdar mach-src+dep+more-srcs) dest token)
                   (for-each (lambda (name)
                               (cp/ln (at-source name) (at-dir name)))
                             (cdr mach-src+dep+more-srcs)))]

       ,(compilation-preamble-target cmacros.so (list machine.def (at-dir "layout.ss"))
                                     (list))

       ,(compilation-preamble-target priminfo.so (list (at-dir "primdata.ss"))
                                     (list cmacros.so))

       ,(compilation-preamble-target env.so (list (at-dir "primref.ss"))
                                     (list cmacros.so priminfo.so))

       ,(compilation-preamble-target primvars.so (list (at-dir "primref.ss"))
                                     (list cmacros.so priminfo.so))

       ,(compilation-preamble-target setup.so (list (at-dir "primref.ss") (at-dir "debug.ss"))
                                     (list cmacros.so priminfo.so))

       ,(compilation-preamble-target mkheader.so type-src-copies
                                     (list cmacros.so priminfo.so primvars.so env.so))

       ,(compilation-preamble-target mkgc.so type-src-copies
                                     (list cmacros.so priminfo.so primvars.so env.so mkheader.so))
       [:target ,nanopass.so ,(cons nanopass.ss
                                    (let ([np-dir (at-source "../nanopass/nanopass")])
                                      (map (lambda (p) (build-path np-dir p)) (ls np-dir))))
                ,(lambda (path token)
                   (run-scheme path
                               (make-compiler-compile-script nanopass.ss path 'library)
                               (list "--libdirs" (~a (at-source "../nanopass")
                                                     (if (eq? 'windows (system-type))
                                                         ";;"
                                                         "::")
                                                     ".")
                                     "--compile-imported-libraries")))]

       ,@(map (lambda (src obj)
                `[:target ,obj ,(list* src nanopass.so (append macro-objs type-src-copies))
                          ,(lambda (obj token)
                             (run-scheme obj
                                         (make-compile-single-script src obj #f)
                                         macro-objs))])
              (append base-srcs compiler-srcs)
              (append base-objs compiler-objs))

       ,@(map (lambda (name)
                (let ([src (at-source (path-replace-suffix name ".ss"))]
                      [obj (at-dir name)])
                  `[:target ,obj ,(list* src nanopass.so (append macro-objs type-src-copies))
                            ,(lambda (obj token)
                               (run-scheme obj
                                           (make-compiler-compile-script src obj 'patch)
                                           macro-objs))]))
              patch-names)

       [:target ,(at-dir "xpatch") ,(map at-dir patch-names)
                ,(lambda (path token)
                   (cat (map at-dir patch-names) path))]

       ,(include-dep "cptypes" (list "fxmap.ss" "cptypes-lattice.ss"))
       ,(include-dep "5_4" (list "../unicode/unicode-char-cases.ss" "../unicode/unicode-charinfo.ss"))
       ,(include-dep "strip" (list "strip-types.ss"))
       ,(include-dep "vfasl" (list "strip-types.ss"))
       ,(include-dep "pbchunk" (list "strip-types.ss"))
       ,(include-dep "cpnanopass" cpnanopass-src-files)
       ,(include-dep "cpprim" cpnanopass-src-files)

       [:target ,petite.boot ,(add-patchfile base-objs)
                ,(lambda (petite.boot token)
                   (run-scheme petite.boot
                               (make-bootfile-script petite.boot '() base-objs)
                               (add-patchfile macro-objs)))]

       [:target ,scheme.boot ,(add-patchfile compiler-objs)
                ,(lambda (scheme.boot token)
                   (run-scheme scheme.boot
                               (make-bootfile-script scheme.boot '("petite") compiler-objs)
                               (add-patchfile macro-objs)))]

       [:target ,scheme.h (,mkheader.so ,@macro-objs)
                ,(lambda (scheme.h token)
                   (run-scheme-header-script scheme.h
                                             (lambda (tmp)
                                               `((mkscheme.h ,tmp ',(string->symbol m))))
                                             (list mkheader.so)))]
       [:target ,equates.h (,mkheader.so ,@macro-objs)
                ,(lambda (scheme.h token)
                   (run-scheme-header-script equates.h
                                             (lambda (tmp) `((mkequates.h ,tmp)))
                                             (list mkheader.so)))]
       ,@(map (lambda (gc.inc mkgc.inc)
                `[:target ,gc.inc (,mkgc.so ,@macro-objs)
                          ,(lambda (gc.inc token)
                             (run-scheme-header-script gc.inc
                                                       (lambda (tmp) `((,mkgc.inc ,tmp)))
                                                       (list mkheader.so mkgc.so)))])
              (list gc-ocd.inc gc-oce.inc gc-par.inc heapcheck.inc)
              (list 'mkgc-ocd.inc 'mkgc-oce.inc 'mkgc-par.inc 'mkheapcheck.inc))

       ;; These targets rebuild boot files in all-at-once mode, but
       ;; independent of whether dependencies changed:
       [:target all (bootall ,@output-headers)
                ,void]
       [:target bootall (,@all-srcs ,@macro-objs ,nanopass.so)
                ,(lambda (token)
                   (run-scheme "all at once"
                               (make-compile-at-once-script base-srcs base-objs petite.boot
                                                            compiler-srcs compiler-objs scheme.boot)
                               (add-patchfile macro-objs)))]

       ;; This target uses a "bootstrap" stamp file to trigger a separate `build` run,
       ;; and it iterates up to three times to find a fixpoint
       [:target ,(at-dir "bootstrap") ,all-srcs
                ,(lambda (path token)
                   (look-for-fixpoint 3 (lambda () (build (find-target "bootall" the-targets))))
                   (fd-close (fd-open-output path :truncate)))]

       #;(end-make-targets))))

  the-targets)

(provide-targets targets-at)
