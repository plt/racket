#lang zuo
(require (only-in "s/main.zuo"
                  [targets-at s-targets-at])
         (only-in "c/main.zuo"
                  [targets-at c-targets-at])
         "makefiles/lib.zuo")

(define (targets-at at-dir [vars (hash)])
  (define Mf-config (at-dir "Mf-config"))
  (unless (file-exists? Mf-config)
    (error "no \"Mf-config\" - not running from a build directory?"))
  (define config (config-file->hash Mf-config))

  (define m (hash-ref config 'm))
  (define mboot (hash-ref config 'mboot m))

  ;; subdirectories where we create a "main.zuo" that bounce to
  ;; one in the source area
  (define bounce-dirs
    '("c" "s" "mats" "examples"))
  (define bounce-files
    (map (lambda (d) (at-dir d "main.zuo")) bounce-dirs))
  (define bounce-scripts
    (map (lambda (d)
           (~a "#lang zuo\n"
               (~s `(define config (config-file->hash (at-source ".." "Mf-config")))) "\n"
               (~s `(build/command-line* (dynamic-require (build-path ((make-at-dir (at-source ".." ".."))
                                                                       (hash-ref config 'srcdir))
                                                                      ,d
                                                                      "main.zuo")
                                                          'targets-at)
                                         at-source))))
         bounce-dirs))

  (define boot-src-dir
    (let ([here-dir (at-dir ".." "boot" mboot)])
      (if (directory-exists? here-dir)
          here-dir
          (at-source "boot" mboot))))

  (define boot-file-names
    (append
     '(;; the boot files proper
       "petite.boot" "scheme.boot"
       ;; machine-specific header files:
       "scheme.h" "equates.h"
       ;; GC traversal functions
       "gc-ocd.inc" "gc-oce.inc" "gc-par.inc" "heapcheck.inc")
     ;; extra boot files from source
     (let ([config-file (build-path boot-src-dir "Mf-config")])
       (if (file-exists? config-file)
           (shell->strings (hash-ref (config-file->hash config-file) 'extraBootFiles ""))
           '()))))

  (define boot-files
    (map (lambda (file) (at-dir "boot" m file)) boot-file-names))

  (define (build-kernel-only?)
    (string=? (hash-ref config 'buildKernelOnly "no") "yes"))
  (define (check-not-kernel-only)
    (when (build-kernel-only?)
      (error "target does not apply to a kernel-only configuration")))

  ;; Cross-builds for a machine type that is specified as an argument;
  ;; the machine type defaults to the `defaultm` configuration entry, and
  ;; that default is normally useful if the current machine type is "pb"
  (define (cross-build-boot token args ccopts make-targets)
    (unless (<= (length args) 1) (error "expected optional <machine>" args))
    (define xm (if (null? args)
                   (hash-ref config 'defaultm)
                   (car args)))
    (define dir (at-dir ".." (~a "xc-" xm)))
    (define s-dir (build-path dir "s"))
    (mkdir* s-dir)
    (display-to-file (~a "m=" xm "\n"
                         "hostm=" m "\n"
                         "hostworkarea=" (build-path "../.." m) "\n")
                     (build-path dir "Mf-config")
                     :truncate)
    (let ([targets (s-targets-at (make-at-dir s-dir)
                                 vars
                                 ccopts)])
      (build (map (lambda (t) (find-target t targets)) make-targets)
             (hash)
             token))
    (define boot-xm-dir (at-dir "../boot" xm))
    (mkdir* boot-xm-dir)
    (for-each (lambda (file)
                (cp (build-path dir "boot" xm file)
                    (build-path boot-xm-dir file)))
              boot-file-names))

  (define (run-tests token name [vars vars])
    (check-not-kernel-only)
    (build (find-target name
                        ((dynamic-require (at-source "mats/main.zuo") 'targets-at)
                         (make-at-dir (at-dir "mats"))
                         vars))
           (hash)
           token))

  (define the-targets
    (make-targets
     `(;; Builds the kernel (C code) and boot files (Scheme code):
       [:target build (workarea kernel)
                ,(lambda (token)
                   (unless (build-kernel-only?)
                     (build (find-target "bootstrap" (s-targets-at (make-at-dir (at-dir "s")) vars))
                            (hash)
                            token)))]

       ;; Builds just the kernel (C code):
       [:target kernel (workarea)
                ,(lambda (token)
                   (build (find-target "build" (c-targets-at (make-at-dir (at-dir "c")) vars))
                          (hash)
                          token))]

       [:target install ()
                ,(lambda (token)
                   (check-not-kernel-only)
                   ((dynamic-require (at-source "makefiles/install.zuo") 'install)
                    at-dir))]

       [:target uninstall ()
                ,(lambda (token)
                   (check-not-kernel-only)
                   ((dynamic-require (at-source "makefiles/install.zuo") 'install)
                    at-dir
                    (hash)
                    #t))]

       [:target run ()
                ,(lambda (token . args)
                   (cond
                     [(equal? (hash-ref config 'exeSuffix "") ".html")
                      ;; must be an Emscripten build...
                      (shell (build-shell "cd" (string->shell (at-dir "bin" m))
                                          "&& node scheme.js"))]
                     [else
                      (define t (find-target "run" (s-targets-at (make-at-dir (at-dir "s")) vars)))
                      (build (command-target->target t args)
                             (hash)
                             token)]))
                :command]

       ;; See `cross-build-boot`: builds cross-compiler in unsafe mode, skips examples
       [:target bootquick (kernel)
                ,(lambda (token . args)
                   (check-not-kernel-only)
                   (cross-build-boot token args (hash) '("all")))
                :command]

       ;; See `cross-build-boot`: builds cross-compiler in safe mode, skips examples
       [:target boot ()
                ,(lambda (token . args)
                   (check-not-kernel-only)
                   (cross-build-boot token args (hash 'o 2 'd 3 'i #t) '("all" "examples")))
                :command]

       [:target test-some () ,(lambda (token) (run-tests token "test-some"))]
       [:target test () ,(lambda (token) (run-tests token "test"))]
       [:target test-more () ,(lambda (token) (run-tests token "test-more"))]

       [:target coverage (kernel)
                ,(lambda (token)
                   (check-not-kernel-only)
                   (when (glob-match? "t*" m)
                     (error "coverage doesn't work with threads enabled"))
                   (let ([vars (hash-set vars 'c "t")])
                     (build (find-target "bootstrap" (s-targets-at (make-at-dir (at-dir "s"))
                                                                   (hash-set vars 'p "t")))
                            (hash)
                            token)
                     (run-tests token "all" vars)
                     (run-tests token "coverage" vars)))]

       ;; The `reset` target discards the results in "boot" and puts back links to (or copies of)
       ;; to the versions that are used to seed the build
       [:target reset ()
                ,(lambda (token)
                   (for-each (lambda (f) (when (file-exists? f) (rm f))) boot-files)
                   (build (map (lambda (f) (find-target f the-targets)) boot-files)
                          (hash)
                          token))]

       [:target docs ()
                ,(lambda (token)
                   (check-not-kernel-only)
                   (mkdir* (at-dir "csug"))
                   (define mf (~a "m=" m "\n"
                                  "srcdir=" (find-relative-path (at-dir "csug") (at-source "csug")) "\n"
                                  (file->string (at-source "makefiles/Makefile-csug.in"))))
                   (display-to-file mf (at-dir "csug/Makefile") :truncate)
                   (shell/wait "make"
                               (hash 'dir (at-dir "csug"))))]

       ,@(if (eq? 'windows (system-type))
             `([:target all-dlls (build)
                        ,(lambda (token)
                           (for-each*
                            '("dll" "static")
                            (lambda (runtimeAs)
                              (for-each*
                               '("dll" "exe")
                               (lambda (linkAs)
                                 (unless (and (equal? runtimeAs (hash-ref config 'runtimeAs #f))
                                              (equal? linkAs (hash-ref config 'linkAs #f)))
                                   (fd-write (fd-open-output 'stdout)
                                             (~a "Also buidling variant " runtimeAs " " linkAs "...\n"))
                                   (define var-dir (at-dir (~a "c-" runtimeAs "-" linkAs)))
                                   (mkdir* var-dir)
                                   (build (find-target "lib" (c-targets-at (make-at-dir var-dir)
                                                                           (hash-set* vars
                                                                                      'runtimeAs runtimeAs
                                                                                      'linkAs linkAs)))
                                          (hash)
                                          token)))))))])
             '())

       ;; Internal targets ----------------------------------------

       ;; Builds out an initial workarea, with links to book files
       [:target workarea (,@bounce-files ,@boot-files)
                ,void
                :quiet]

       ,@(map (lambda (dir file script)
                `[:target ,file (,(input-data-target 'script script))
                          ,(lambda (path token)
                             (mkdir* (at-dir dir))
                             (display-to-file script path :truncate))])
              bounce-dirs
              bounce-files
              bounce-scripts)

       ,@(map (lambda (name dest)
                `[:target ,dest ()
                          ,(lambda (dest token)
                             (unless (file-exists? dest)
                               (define src (build-path boot-src-dir name))
                               (unless (file-exists? src)
                                 (error "missing prebuilt boot file" src))
                               (mkdir* (at-dir "boot" m))
                               (cp/ln src dest)))])
              boot-file-names
              boot-files)

       ;; Needed to keep the initial-boot-file info here instead of in "boot"
       [:db-dir ,(at-dir ".")]

       #;(end-make-targets))))

  the-targets)

(provide-targets targets-at)
